#!/bin/python

import os, sys, yaml, requests #Imports necessary libraries
import MCGTools as mt #Imports MCGTools (as mt) so we can use it's functions (goget, DIRector, megamd5, output)
from threading import Thread

output = mt.output #Lets us call output without "mt." at the beginning

output('#######################################################################')
output('#   GoGetter - Threaded                                               #')
output('#   MCG Jazz HTTP File Retrieval Tool                                 #')
output('#                                                                     #')
output('#   Written by Connor Ehrgood 8/29/2022                               #')
output('#   cehrgood@manchesterbidwell.org, connor@ebcom.co, (724) 825-7313   #')
output('#######################################################################')
output('Initializing...')

name = sys.argv[1] #Extracts the name argument provided in the terminal
config_file = sys.argv[2] #Extracts the config file argument provided in the terminal
directory = os.path.join(os.getcwd(), name) #Generates the directory path based upon the current working directory and the name provided

with open(config_file, 'r') as config_open: #Opens the config file provided
    config = yaml.safe_load(config_open) #Saves the contents of the config file as a list

files = config['files'] #Parses the files to be downloaded into a list
dir_list = config['directories'] #Parses the directories to be created into a nested list

mt.director(directory, dir_list) #Calls DIRector to create the specified folder tree



def move(current_addr, output_addr, server):

    output(f'{output_addr} - Thread initialized.')
 
    file_hash = 'file_hash' #Defining the hash strings and setting them to arbitrary, non-equal values
    verify_hash = 'verify_hash'
    
    while(file_hash != verify_hash):

        mt.goget(current_addr, output_addr) #Calls goget to retrieve the specified file

        file_hash = mt.megamd5(output_addr) #Calls megamd5 to generates the MD5 hash for the file

        output(f'{output_addr} - Verifying...')

        verify_hash = mt.remmd5(current_addr) #Generates an MD5 hash of the remote file
        output(f'{output_addr} - File Hash: {file_hash}')
        output(f'{output_addr} - Verify Hash: {verify_hash}')

        if(file_hash == verify_hash): #Checks to make sure the hash of the local file and remote file are the same
            output(f'{output_addr} - File integrity verified. Finishing.')
        else:
            output(f'{output_addr} - File issue detected. Retrying.')

    output(f'{output_addr} - Completed!')



threads = []
for file in files:
    current_addr = file['url'] #Parses the URL of the file to be downloaded
    current_dir = file['dir'] #Parses the directory the file is to be downloaded to
    server = current_addr.rsplit('/', 2)[0] #Determines what the address of the server is for API calls
    remote_name = current_addr.rsplit('/', 1)[-1] #Determines the name of the remote file
    local_name = f'{name}_{remote_name}' #Generates the name to be used for the file
    output_addr = os.path.join(name, current_dir, local_name) #Generates the full output path for the file

    t = Thread(target=move, args=(current_addr, output_addr, server, ))
    threads.append(t)
    t.start()


for t in threads: #Waits for threads to complete
    t.join()


print('GoGetter Done!')