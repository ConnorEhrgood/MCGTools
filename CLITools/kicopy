#!/venv/MCGTools/bin/python3

#This is a program created specifically to download a list of files from AJA KiPros

import os, sys, yaml, requests #Imports necessary libraries
import MCGTools as mt #Imports MCGTools (as mt) so we can use it's functions (goget, DIRector, megamd5, output)
from threading import Thread

output = mt.output #Lets us call output without "mt." at the beginning

output('#######################################################################')
output('#   KiCopy - Threaded                                                 #')
output('#   MCG Jazz HTTP File Retrieval Tool for AJA KiPro                   #')
output('#                                                                     #')
output('#   Written by Connor Ehrgood 8/29/2022                               #')
output('#   cehrgood@manchesterbidwell.org, connor@ebcom.co, (724) 825-7313   #')
output('#######################################################################')
output('Initializing...')

if len(sys.argv) < 3: #Checks to make sure the correct number of arguments is provided
    output('ERROR: A name and config file file MUST be provided! Usage: kicopy <NAME> <CONFIG FILE>')
    exit(1)
elif len(sys.argv) > 3:
    output('ERROR: Too many arguments provided! Usage: kicopy <NAME> <CONFIG FILE>')
    exit(1)

name = sys.argv[1] #Extracts the name argument provided in the terminal
config_file = sys.argv[2] #Extracts the config file argument provided in the terminal
directory = os.path.join(os.getcwd(), name) #Generates the directory path based upon the current working directory and the name provided

with open(config_file, 'r') as config_open: #Opens the config file provided
    config = yaml.safe_load(config_open) #Saves the contents of the config file as a list

files = config['gogetter_files'] #Parses the files to be downloaded into a list
dir_list = config['gogetter_directories'] #Parses the directories to be created into a nested list

mt.director(directory, dir_list) #Calls DIRector to create the specified folder tree



def move(server, server_files, name): #The function that each thread will run

    output(f'{server} - Thread initialized.')

    output(f'{server} - Setting media state to DATA-LAN:')
    output(str(requests.get(f'{server}/config', params = 'action=set&paramid=eParamID_MediaState&value=1', timeout = 10))) #Makes the media state call to the KiPro and prints the response

    for file in server_files: 

        current_addr = file['url'] #Parses url form list of files
        current_dir = file['dir'] #Parses directory from list of files
        remote_name = current_addr.rsplit('/', 1)[-1] #Determines the name of the remote file
        local_name = f'{name}_{remote_name}' #Generates the name to be used for the file
        output_addr = os.path.join(name, current_dir, local_name) #Generates the full output path for the file


        file_hash = 'file_hash' #Defining the hash strings and setting them to arbitrary, non-equal values
        verify_hash = 'verify_hash'
    
        while(file_hash != verify_hash): #If the hashs of the downloaded file and the remote file aren't the same, keep doing this

            mt.goget(current_addr, output_addr) #Calls goget to retrieve the specified file

            file_hash = mt.megamd5(output_addr) #Calls megamd5 to generates the MD5 hash for the file

            output(f'{output_addr} - Verifying...')

            verify_hash = mt.remmd5(current_addr) #Generates an MD5 hash of the remote file
            output(f'{output_addr} - File Hash: {file_hash}')
            output(f'{output_addr} - Verify Hash: {verify_hash}')

            if(file_hash == verify_hash): #Checks to make sure the hash of the local file and remote file are the same
                output(f'{output_addr} - File integrity verified. Finishing.')
            else:
                output(f'{output_addr} - File issue detected. Retrying.')

    output(f'{server} - Setting media state to RECORD-PLAY:')
    output(str(requests.get(f'{server}/config', params = 'action=set&paramid=eParamID_MediaState&value=0', timeout = 10))) #Makes the media state call to the KiPro and prints the response

    output(f'{server} - Completed!')

servers = {}

for file in files: #Generates a list of files for each server to download sequentially. Prevents KiPros from killing connections when multiple requests are made.
    current_addr = file['url'] #Parses the URL of the file to be downloaded
    server = current_addr.rsplit('/', 2)[0] #Determines what the address of the server is
    current_dir = file['dir'] #Parses the directory the file is to be downloaded to

    if server in servers:
        servers[server].append(file) #If the server for this particular file is already in the list of servers, just append the file to the list for that server
    else:
        servers[server] = [file] #If the server for this particular file is not in the list of servers, add the server and append the file to it's list

threads = []

for server in servers: #Spins up a thread to download the files from each server in parrallel

    server_files = servers[server]

    t = Thread(target=move, args=(server, server_files, name, )) #Defining thread
    threads.append(t) #Adding to the list of threads so it can be joined later
    t.start() #Starts the thread

for t in threads: #Wait for all threads to complete
    t.join()

print('\x1b[6;30;42m' + 'All Done!' + '\x1b[0m')