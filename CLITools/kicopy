#!/bin/python

#This is a program created specifically to download a list of files from AJA KiPros

import os, sys, yaml, requests #Imports necessary libraries
import MCGTools as mt #Imports MCGTools (as mt) so we can use it's functions (goget, DIRector, megamd5, output)
from threading import Thread

output = mt.output #Lets us call output without "mt." at the beginning

output('#######################################################################')
output('#   KiCopy - Threaded                                                 #')
output('#   MCG Jazz HTTP File Retrieval Tool for AJA KiPro                   #')
output('#                                                                     #')
output('#   Written by Connor Ehrgood 8/29/2022                               #')
output('#   cehrgood@manchesterbidwell.org, connor@ebcom.co, (724) 825-7313   #')
output('#######################################################################')
output('Initializing...')

if len(sys.argv) < 3: #Checks to make sure the correct number of arguments is provided
    output('ERROR: A name and config file file MUST be provided! Usage: kicopy <NAME> <CONFIG FILE>')
    exit(1)
elif len(sys.argv) > 3:
    output('ERROR: Too many arguments provided! Usage: kicopy <NAME> <CONFIG FILE>')
    exit(1)

name = sys.argv[1] #Extracts the name argument provided in the terminal
config_file = sys.argv[2] #Extracts the config file argument provided in the terminal
directory = os.path.join(os.getcwd(), name) #Generates the directory path based upon the current working directory and the name provided

with open(config_file, 'r') as config_open: #Opens the config file provided
    config = yaml.safe_load(config_open) #Saves the contents of the config file as a list

files = config['files'] #Parses the files to be downloaded into a list
dir_list = config['directories'] #Parses the directories to be created into a nested list

mt.director(directory, dir_list) #Calls DIRector to create the specified folder tree



def move(current_addr, output_addr, server):

    output(f'{output_addr} - Thread initialized.')

    output(f'{output_addr} - Setting media state to DATA-LAN:')
    output(str(requests.get(f'{server}/config', params = 'action=set&paramid=eParamID_MediaState&value=1', timeout = 10))) #Makes the media state call to the KiPro and prints the response

    file_hash = 'file_hash' #Defining the hash strings and setting them to arbitrary, non-equal values
    verify_hash = 'verify_hash'
    
    while(file_hash != verify_hash):

        mt.goget(current_addr, output_addr) #Calls goget to retrieve the specified file

        file_hash = mt.megamd5(output_addr) #Calls megamd5 to generates the MD5 hash for the file

        output(f'{output_addr} - Verifying...')

        verify_hash = mt.remmd5(current_addr) #Generates an MD5 hash of the remote file
        output(f'{output_addr} - File Hash: {file_hash}')
        output(f'{output_addr} - Verify Hash: {verify_hash}')

        if(file_hash == verify_hash): #Checks to make sure the hash of the local file and remote file are the same
            output(f'{output_addr} - File integrity verified. Finishing.')
        else:
            output(f'{output_addr} - File issue detected. Retrying.')

    output(f'{output_addr} - Setting media state to RECORD-PLAY:')
    output(str(requests.get(f'{server}/config', params = 'action=set&paramid=eParamID_MediaState&value=0', timeout = 10))) #Makes the media state call to the KiPro and prints the response

    output(f'{output_addr} - Completed!')




threads = []
for file in files:
    current_addr = file['url'] #Parses the URL of the file to be downloaded
    current_dir = file['dir'] #Parses the directory the file is to be downloaded to
    server = current_addr.rsplit('/', 2)[0] #Determines what the address of the server is for API calls
    remote_name = current_addr.rsplit('/', 1)[-1] #Determines the name of the remote file
    local_name = f'{name}_{remote_name}' #Generates the name to be used for the file
    output_addr = os.path.join(name, current_dir, local_name) #Generates the full output path for the file

    t = Thread(target=move, args=(current_addr, output_addr, server, ))
    threads.append(t)
    t.start()

# wait for the threads to complete
for t in threads:
    t.join()


print('\x1b[6;30;42m' + 'All Done!' + '\x1b[0m')